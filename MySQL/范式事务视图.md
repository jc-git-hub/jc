# 数据库进阶  

## 数据库三范式    

### 表关系  

1. 一对一 
2. 一对多 
3. 多对一
4. 多对多

* 第一范式  数据列的原子性 字段不能再进行拆分    1NF

  ```
  用户id 姓名 性别  年龄  联系方式    # 这个可以继续拆分          不满足第一范式  
  1     张三  男    18   tel:13888888888 qq 123456 家庭住址:dfdsaf
  
  用户id  姓名 性别 年龄  手机 qq 省份 市区 县  # 直到每个列不能继续拆分为止    
  ```

  

* 第二范式  2NF  先要满足第一范式  要求所有的列必须跟主键相关  也就是消除部分依赖 

  ```
  商品id 商品名称 价格 商品详情 重量 有效期 分类 分类描述  # 分类描述 并不依赖于主键  需要拆分 
  
  存在问题: 
  	数据冗余 : 每条记录含有相同的信息  
  	删除异常: 删除分类描述 把商品也删掉了  
  	插入异常: 不知道分类  商品没法保存
  	更新异常: 更新分类信息 所有的商品信息都得更新  
  
  拆分以后:
  
  商品id 商品名称  价格 重量 商品详情 有效期 分类id       # 一个商品只属于一个分类的 情况   一个分类里边有多个商品 
   
  分类id 分类名称  分类描述 
  
  
  ```

  

* 第三范式    3NF  满足第二范式基础上  消除传递依赖     多对多  

  ```
  商品名称 价格 商品详情 重量 有效期 分类 分类描述   分类描述并不依赖于主键   
  
  存在问题:
  	数据冗余 : 每条记录含有相同的信息  
  	删除异常: 删除分类描述 把商品也删掉了  
  	插入异常: 不知道分类  商品没法保存
  	更新异常: 更新分类信息 所有的商品信息都得更新 
  
  需要拆分  
  
  商品id 商品名称  价格 重量 商品详情 有效期    # 一个商品属于多个分类的情况   一个分类里边有多个商品 
  
  分类id 分类名称  分类描述     
  
  分类id  商品id     
  2		1
  3		1
  
  ```

  



	#### 范式缺点 : 

​	虽然  写 （插入、更新、删除）保证没异常但是 读麻烦了    

​	读需要多张表一起查  



#### 反范式  

* 适当的反范式   
  * 在商品表上多加一个字段   总价  总价等于单价乘以数量     好处是 一张表就可以得到结果  坏处是  冗余   
  * 好处是 读的效率 高了  





## 事务  

> 简单来说就是保证 一组数据库操作  要么全部成功  要么全部失败  
> mysql 事务是在 引擎层 实现的   mysql支持 多引擎  并不所有的引擎都支持事务 innodb引擎支持事务 



### 事务特性 

a atomicity   原子性

c consistency  一致性 

i  isolation  隔离性 

d  durability 持久性  





#### 隔离性    

##### 隔离级别   从低到高   

* 读未提交   read uncommitted  
  * 一个事务 还没有提交  这时候所做的变更被其它事务看到了      脏读   如何解决脏读   读提交 
* 读提交    read committed
  * 一个事务提交以后他所做的变更才会被其它事务看到   
    * 问题 :  不可重复读 (同一个事务 同样的查询 两次结果不一样 )  如何解决  可重复读       -------   针对于更新操作  
* 可重复读  repeatable read 
  * 开始读数据的时候  不允许你再更新 update 了 
  *  一个事务 执行过程中看到的数据总是跟这个事务在启动的时候看到的数据是一致的，未提交的变更对于其它事务也是不可见的
    * 出现问题  : 幻读  ---------- 针对的是 insert 操作  
* 序列化 串行化     serializable 
  * 读+读锁    写 + 写锁  当出现读写冲突的时候 后边的事务必须等到前面的事务执行完成才可以   

Oracle      SQL Server      默认隔离级别  是  read committed

-----------------------------------

MySQL、PostgreSQL      默认隔离级别  是   repeatable read 

```
create table T(id int(11))engine=innodb;

insert into T values(1);
```

| 事务A                | 事务B       |
| -------------------- | ----------- |
| 启动事务 查询得到值1 | 启动事务    |
|                      | 查询得到值1 |
|                      | 将值1 改成2 |
| 查询值得到 V1        |             |
|                      | 提交事务B   |
| 查询得到值V2         |             |
| 提交事务A            |             |
| 查询得到值V3         |             |

问题 ： 不同的隔离级别  V1 V2 V3的值分别是什么?

1. 读未提交    V1 是2  V2 V3也是 2  事务B虽然没有提交但是 变更已经被A看到了

2. 读提交 V1 是 1  V2的值是2  V3 也是2  

3. 可重复读    事务在执行期间看到数据前后必须是一致的 所以 事务A提交之前 看得到的值 跟刚开始看到的是一样的 

   所以V1 V2的值是 1  V3 2  

4. 事务B将1改成2 上锁 事务A提交以后 事务B才可以继续执行 从A的角度看 V1 V2 1 V3的值是2 



总结: 不同的隔离级别  结果是不一样的  如果有需求 将数据库迁移 比如将mysql 迁移到 Oracle 一定要注意修改隔离级别 

#### 查看隔离级别 

```
show variables like 'transaction_isolation';  
```

#### 修改隔离级别 

```
编辑  C:\ProgramData\MySQL\MySQL Server 5.7\my.ini  

[mysqld] 
transaction-isolation =  REPEATABLE-READ 
该配置文件先备份配置文件 
改好后重启服务
```



### 表复制 数据复制 

```
mysql> create table stars1 like stars;  #复制stars表 为 stars1 
mysql> insert into stars1 select * from stars; 
```



### 开启事务  

* begin        commit   rollback

* start transaction  

  ​	

```  
begin; #开启事务 

操作1

rollback; #在提交之前回滚  



myisam 引擎不支持 事务   
alter table 表名 engine=innodb; #修改为innodb引擎才可以 

如果删除了数据之后 立马commit  那么就会导致 不能回滚  



mysql> insert into test1(username,age) values('zhangsan3',18),('lisi3',19),('wangwu3',20);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> savepoint p3;
Query OK, 0 rows affected (0.00 sec)

delete from test1;

rollback to p3;


p3之前 有 p2  p1  那么  先p3 再 p2  p1 可以回滚 
如果第一次 回滚到 p1 那么会导致 p2 p3 回滚不过去了
```



## 视图  

> 临时表   
>
> ? view

```
mysql> create view 视图名称 as  sql语句; #把经常操作的sql语句的结果放到临时表中 
mysql> create view v_userindo as  select userid,username from userinfo where userid between 231625 and 231658; 

mysql> desc v_userinfo;    # userid,username

原表删除  视图失效  原标恢复  视图恢复  


mysql> show create view v_userindo\G  #显示创建视图的过程 
drop view 视图名称;#删除视图  

 
```

## 存储过程  

> 存的是一个函数  

```
mysql> ? procedure

\d  //更改结束符号 
mysql> create procedure p2()
    -> begin
    -> set @i=1;
    -> while @i<=100000 do
    -> insert into user(username,tel,password) values(concat('user',@i),concat('1388888',rand()*100),concat('user',@i));
    -> set @i=@i+1;
    -> end while;
    -> end //
Query OK, 0 rows affected (0.00 sec)

\d ;

call p2;

show procedure status\G   
show create procedure p2\G 


```

